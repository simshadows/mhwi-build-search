#!/usr/bin/env python3
# -*- coding: ascii -*-

"""
Filename: autogen_decorations_data.py
Author:   <contact@simshadows.com>

Reads the decorations data file, and generates the source files.
"""

from common import (json_read,
                    file_write,
                    is_upper_snake_case,
                    is_safe_name,
                    skill_id_to_source_identifier_fromforeign)

JSON_PATH  = "./data/database_decorations.json"
H_PATH = "./src/database/database_decorations.h"
CPP_PATH = "./src/database/autogenerated/database_decorations.cpp"

#########################################################################################

H_BASE = """
/*
 * This file is auto-generated.
 * Do not edit directly!
 */

#ifndef DECORATIONS_DATABASE_H
#define DECORATIONS_DATABASE_H

#include <string>
#include <vector>

#include "../core/core.h"

namespace DecorationsDatabase
{{

using MHWIBuildSearch::Decoration;
using MHWIBuildSearch::Skill;

extern const std::array<const Decoration*, {num_decos}> g_all_decorations;

const Decoration* get_decoration(const std::string& deco_id) noexcept;

}} // namespace

#endif // DECORATIONS_DATABASE_H

"""

#########################################################################################

CPP_BASE = """
/*
 * This file is auto-generated.
 * Do not edit directly!
 */

#include <unordered_map>

#include "../database_skills.h"
#include "../database_decorations.h"

namespace DecorationsDatabase
{{


// TODO: Use these for static asserts?
//static constexpr unsigned int k_SIMPLE_DECO_SKILL_LVL = 1;
//static constexpr unsigned int k_COMPLEX_DECO_SIZE = 4;


{deco_definitions}


static const std::unordered_map<std::string, const Decoration*> g_decorations_map = {{
{deco_map_elements}
}};


const std::array<const Decoration*, {num_decos}> g_all_decorations = {{
{deco_array_elements}
}};


const Decoration* get_decoration(const std::string& deco_id) noexcept {{
    return g_decorations_map.at(deco_id);
}}


}} // namespace

"""

#########################################################################################

def validate_data(d):
    names = set() # Used only for validation
    for (_, t) in d.items():

        # ID
        if not is_upper_snake_case(t["deco_id"]):
            raise ValueError("IDs must be upper case letters, numbers, or underscores.")

        # Names
        if not is_safe_name(t["deco_name"]):
            raise ValueError("Name may not be safe.")
        elif t["deco_name"] in names:
            raise ValueError("Names must be unique.")
        names.add(t["deco_name"])

    return


def parse_simple_decos(j):
    decos = {}
    intermediate_simple_decos = {}

    for (deco_id, deco_json) in j.items():
        t = {
                # Name to bind globally in the C++ source code
                "identifier": "g_decoration_" + deco_id.lower(),

                # Struct data
                "deco_id":   deco_id,
                "deco_name": deco_json["name"] + " Jewel " + str(deco_json["slot"]),
                "slot_size": deco_json["slot"],
                "skills":    {skill_id_to_source_identifier_fromforeign(deco_json["skill"]): 1},
            }
        decos[deco_id] = t

        u = {
                "deco_id":      deco_id,
                "partial_name": deco_json["name"],
                "skill":        skill_id_to_source_identifier_fromforeign(deco_json["skill"]),
            }
        intermediate_simple_decos[deco_id] = u
    return (decos, intermediate_simple_decos)

def parse_compound_decos(j, intermediate_simple_decos):
    decos = {}
    for combo_json in j:
        for left_simple_deco_id in combo_json["left_side"]:
            for right_simple_deco_id in combo_json["right_side"]:

                left = intermediate_simple_decos[left_simple_deco_id]
                right = intermediate_simple_decos[right_simple_deco_id]

                deco_id = left_simple_deco_id + "_" + right_simple_deco_id + "_COMPOUND"

                t = {
                        # Name to bind globally in the C++ source code
                        "identifier": "g_decoration_" + deco_id.lower(),

                        # Struct data
                        "deco_id":   deco_id,
                        "deco_name": left["partial_name"] + "/" + right["partial_name"] + " Jewel 4",
                        "slot_size": 4,
                        "skills":    {left["skill"]: 1, right["skill"]: 1},
                    }

                if (deco_id in decos):
                    raise ValueError("IDs must be unique.")
                elif (left["partial_name"] == right["partial_name"]):
                    raise ValueError("Both sides must have different names.")
                elif (left["skill"] == right["skill"]):
                    raise ValueError("Both sides must represent different skills.")

                decos[deco_id] = t
    return decos

def parse_4slot_singleskill_decos(j, intermediate_simple_decos):
    decos = {}
    for (base_simple_deco_id, skill_lvls_list) in j.items():
        for skill_lvl in skill_lvls_list:

            base = intermediate_simple_decos[base_simple_deco_id]

            deco_id = base_simple_deco_id + "_" + str(skill_lvl) + "X"

            if (skill_lvl == 2):
                deco_name = base["partial_name"] + " Jewel+ 4"
            elif (skill_lvl == 3):
                deco_name = "Hard " + base["partial_name"] + " Jewel 4"
            else:
                raise ValueError("Currently unsupported size-4 single-skill decoration size.")

            t = {
                    # Name to bind globally in the C++ source code
                    "identifier": "g_decoration_" + deco_id.lower(),

                    # Struct data
                    "deco_id":   deco_id,
                    "deco_name": deco_name,
                    "slot_size": 4,
                    "skills":    {base["skill"]: skill_lvl},
                }

            if (deco_id in decos):
                raise ValueError("IDs must be unique.")

            decos[deco_id] = t
    return decos

def parse_decos():
    j = json_read(JSON_PATH)

    (decos1, intermediate_simple_decos) = parse_simple_decos(j["simple_decorations"])
    validate_data(decos1)
    decos2 = parse_compound_decos(j["4slot_compound_decorations_batch_definitions"], intermediate_simple_decos)
    validate_data(decos2)
    decos3 = parse_4slot_singleskill_decos(j["4slot_single_skill_decorations"], intermediate_simple_decos)
    validate_data(decos3)

    decos = decos1
    if len(set(decos) & set(decos2)):
        raise ValueError("IDs must be unique.")
    decos.update(decos2)
    if len(set(decos) & set(decos3)):
        raise ValueError("IDs must be unique.")
    decos.update(decos3)

    return decos

def generate_decos_source():
    decos = parse_decos()

    deco_definitions    = []
    deco_map_elements   = []
    deco_array_elements = []
    num_decos           = len(decos)

    for (_, t) in decos.items():
        skills = []
        for (skill_identifier, lvl) in t["skills"].items():
            skills.append(f"        {{ &{skill_identifier}, {lvl} }},")
        skills_str = "\n".join(skills)

        deco_definitions.append(
                    f"const Decoration {t['identifier']} = {{\n"
                    f"    \"{t['deco_id']}\", // id\n"
                    f"    \"{t['deco_name']}\", // name\n"
                    f"    {t['slot_size']}, // slot_size\n"
                    f"    {{ // skills\n"
                    f"{skills_str}\n"
                    f"    }}\n"
                    f"}};"
                )
        deco_map_elements.append(
                    f"    {{ \"{t['deco_id']}\", &{t['identifier']} }},"
                )
        deco_array_elements.append(
                    f"    &{t['identifier']},"
                )

    h_file_data = H_BASE.format(
            num_decos=num_decos,
        )
    file_write(H_PATH, data=h_file_data)

    cpp_file_data = CPP_BASE.format(
            deco_definitions="\n\n".join(deco_definitions),
            deco_map_elements="\n".join(deco_map_elements),
            deco_array_elements="\n".join(deco_array_elements),
            num_decos=num_decos,
        )
    file_write(CPP_PATH, data=cpp_file_data)

generate_decos_source()

